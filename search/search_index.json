{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<ul> <li> <p> SV (SystemVerilog)</p> <p>Read about SystemVerilog language features from the LRM, coding examples, OOP, etc. </p> <p> Read more</p> </li> <li> <p> UVM</p> <p>Read about Coding Guidelines, Templates, UVCs, Coverage, Register Model, etc. </p> <p> Read more</p> </li> <li> <p> IP blocks</p> <p>List of IP blocks to develop simulation verification environments using Universal Verification Methodology (UVM).</p> <p> Read more</p> </li> <li> <p> Tools Guides</p> <p>Scripts, Makefiles and documentation about simulation tools from the major vendors.</p> <p> Read more</p> </li> <li> <p> Contacts</p> <p>Contact our team.</p> <p> Read more</p> </li> </ul>"},{"location":"contacts/","title":"Direct contacts","text":"<p>Ciro Fabian Bermudez Marquez - Verification Engineer</p> <p>Luis Enrique Namigtle Jimenez - Verification Engineer</p>"},{"location":"ip-blocks/","title":"IP blocks","text":"<ul> <li> <p> gpio_uvc</p> <p>This is a UVC designed to manage synchronous and asynchronous GPIOs. It is typically used to drive reset and chip address pins.</p> <p> Go</p> </li> <li> <p> clk_gen_uvc</p> <p>This is a UVC design to generate related clock signal with jitter and phase controls.</p> <p> Go</p> </li> <li> <p> vrf_utils</p> <p>This is a collection of useful tools make to UVM verification easier,  it includes formatting and linting scripts, UVM code generator a RAL generator.</p> <p> Go</p> </li> </ul>"},{"location":"sv/","title":"SystemVerilog","text":""},{"location":"sv/#summary","title":"Summary","text":""},{"location":"sv/clocking-blocks/","title":"Clocking Blocks","text":""},{"location":"sv/clocking-blocks/#summary","title":"Summary","text":""},{"location":"sv/data-types/","title":"Data Types","text":""},{"location":"sv/data-types/#summary","title":"Summary","text":""},{"location":"sv/interfaces/","title":"Interfaces","text":""},{"location":"sv/interfaces/#summary","title":"Summary","text":""},{"location":"sv/threads/","title":"Threads","text":""},{"location":"sv/threads/#summary","title":"Summary","text":""},{"location":"tools-guides/","title":"Tools Guides","text":""},{"location":"tools-guides/#xilinx-vivado","title":"Xilinx Vivado","text":"<ul> <li> <p> VIVADO Flags</p> <p>Put here some description</p> <p> Go</p> </li> </ul>"},{"location":"tools-guides/vivado/vivado/","title":"VIVADO FLAGS","text":""},{"location":"uvm/","title":"UVM","text":""},{"location":"uvm/#guidelines","title":"Guidelines","text":"<ul> <li> <p> Resource Guide</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> UVM Coding Guidelines</p> <p>Put here some description</p> <p> Reference</p> </li> </ul>"},{"location":"uvm/#templates","title":"Templates","text":"<ul> <li> <p> UVM Sequence Item</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> UVM Sequencer</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> UVM Driver</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> UVM Monitor</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> UVM Agent</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> UVM Agent Config</p> <p>Put here some description</p> <p> Reference </p> </li> <li> <p> UVM Environment</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> UVM Environment Config</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> UVM Test</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> UVM Sequence</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> UVM Scoreboard</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> Coverage</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> Interface</p> <p>Put here some description</p> <p> Reference</p> </li> </ul>"},{"location":"uvm/#register-abstraction-layer-ral","title":"Register Abstraction Layer (RAL)","text":"<ul> <li> <p> Register Model</p> <p>Put here some description</p> <p> Reference</p> </li> <li> <p> Adapter</p> <p>Put here some description</p> <p> Reference</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/","title":"UVM Coding Guidelines","text":"<p>This UVM Coding Guidelines are heavily influenced by:</p> <ul> <li>Easier UVM Coding Guidelines</li> <li>Verification Academy - UVM Coding Guidelines</li> </ul> <p>We encourage users to follow these recommendations so that the code becomes more readable and easier to maintain. By doing so, you will also benefit from better performance and simpler integration.</p>"},{"location":"uvm/guidelines/coding-guidelines/#lexical-guidelines-and-naming-conventions","title":"Lexical Guidelines and Naming Conventions","text":"<ul> <li> <p>Have only one declaration or statement per line.</p> </li> <li> <p>When creating user-defined names for SystemVerilog variables and classes, use lower-case words separated by underscores (as opposed to camelBackStyle).</p> </li> <li> <p>When creating user-defined names for SystemVerilog enum literals, constants, and parameters, use upper-case words separated by underscores.</p> </li> <li> <p>Restrict all user-defined UVM instance names (that is, strings such as component instance names) to the character set a-z, A-Z, 0-9 and _ (underscore).</p> </li> <li> <p>Use shorter names for local variables and longer, more descriptive names for global items such as class names and package names.</p> </li> <li> <p>Use the prefix <code>m_</code> before the names of user-defined class member variables (officially known as class properties in SystemVerilog)</p> </li> <li> <p>Use the names <code>m_sequencer</code>, <code>m_driver</code>, and <code>m_monitor</code> as the instance names of the sequencer, driver, and monitor respectively within every agent.</p> </li> <li> <p>Use the suffixes <code>_env</code> and <code>_agent</code> after the instance names of every env and agent, respectively.</p> </li> <li> <p>Use the name <code>m_config</code> as the instance name of the configuration object within any component or sequence that has one.</p> </li> <li> <p>Use the suffix <code>_config</code> after user-defined configuration class names.</p> </li> <li> <p>Use the suffix <code>_port</code> after user-defined port names</p> </li> <li> <p>Use the suffix <code>_export</code> after user-defined export names.</p> </li> <li> <p>Use the suffix <code>_vif</code> after user-defined virtual interface names.</p> </li> <li> <p>Use the suffix <code>_t</code> after user-defined type definitions introduced using the keyword typedef.</p> </li> <li> <p>Use the suffix <code>_pkg</code> after user-defined package names.</p> </li> <li> <p>Write comments wherever they add value to the source code and help the reader to understand the purpose of the code.</p> </li> <li> <p>Include white space (blank lines, indentation) wherever it helps to make the code more readable.</p> </li> <li> <p>When overriding built-in UVM virtual methods, do not insert the <code>virtual</code> keyword at the start of the overridden method definition.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#general-code-structure","title":"General Code Structure","text":"<ul> <li> <p>Use a consistent file structure and a consistent file naming convention throughout.</p> </li> <li> <p>Each class should be defined within a package (as opposed to defining classes within modules or at file scope).</p> </li> <li> <p>Use <code>`include</code> directives within a package to allow each class to be placed in a separate file</p> </li> <li> <p>Use conditional compilation guards to avoid compiling the same include file more than once.</p> <pre><code>`ifndef BUS_PKG_SV\n`define BUS_PKG_SV\n...\n`endif // BUS_PKG_SV\n</code></pre> </li> <li> <p>Include <code>uvm_macros.svh</code> and <code>import uvm_pkg::*</code> inside each package or module that refers to the UVM base class library.</p> <pre><code>`ifndef BUS_PKG_SV\n`define BUS_PKG_SV\n\npackage bus_pkg;\n  `include \"uvm_macros.svh\"\n  import uvm_pkg::*;\n\n  `include \"bus_tx.sv\"\n  `include \"bus_config.sv\"\n  `include \"bus_driver.sv\"\n  `include \"bus_monitor.sv\"\n  `include \"bus_sequencer.sv\"\n  `include \"bus_agent.sv\"\n  `include \"bus_coverage.sv\"\n  `include \"bus_seq_lib.sv\"\nendpackage\n\n`endif // BUS_PKG_SV\n</code></pre> </li> <li> <p>Use one agent per interface, with a passive monitor and optional sequencer and driver whose existence is determined by the value of the <code>get_is_active</code> method of class <code>uvm_agent</code>.</p> </li> <li> <p>An agent should not instantiate components other than the canonical agent structure of one sequencer, one driver, and one monitor.</p> </li> <li> <p>Use virtual sequences to co-ordinate the stimulus generation activities of multiple parallel agents</p> </li> <li> <p>Checking and functional coverage collection should be performed in checkers, scoreboards, coverage collectors, and other ad hoc subscriber components that are instantiated external to any agent and connected to the analysis port of the monitor.</p> </li> <li> <p>In general, connect agents, checkers, scoreboards, and coverage collectors using analysis ports and exports.</p> </li> <li> <p>UVM envs should be written such that they can be used as top-level envs or reused as sub-envs in other larger verification environments.</p> </li> <li> <p>Use factory overrides and/or the configuration database to adapt the behavior of repurposed UVM components to the needs of a new verification environment.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#clocks-timing-synchronization-and-interfaces","title":"Clocks, Timing, Synchronization, and Interfaces","text":"<ul> <li> <p>Generate clocks and resets in a SystemVerilog module, never in the UVM class-based verification environment and never in a SystemVerilog program.</p> </li> <li> <p>Use SystemVerilog modules in preference to SystemVerilog programs.</p> </li> <li> <p>Use clocking blocks within a SystemVerilog interface in order to sense and drive a synchronous DUT interface.</p> </li> <li> <p>Use modports to enforce the use of clocking blocks where those clocking blocks are accessed through a virtual interface from the UVM verification environment.</p> </li> <li> <p>Use modports that combine a clocking block with asynchronous signals in order to access an interface that combines synchronous and asynchronous signals.</p> </li> <li> <p>In the verification environment, try where possible to confine synchronization to signals in the DUT interface and explicit delays to drivers and monitors, with other UVM components being untimed.</p> </li> <li> <p>If a driver needs to insert variable delays within or between transactions when driving the pins of an interface, this should be handled by storing delays in the transaction passed to the driver.</p> </li> <li> <p>A driver should pull transactions from a sequencer using the non-blocking <code>try_*</code> methods in order to maximize reusability in the scenario where the author cannot know whether the sequence will block the execution of the driver.</p> </li> <li> <p>A driver should only pull down transactions from the sequencer when it needs them.</p> </li> <li> <p>Use the <code>uvm_event</code> or <code>uvm_barrier</code> for ad hoc synchronization between sequences and/or analysis components such as scoreboards.</p> </li> <li> <p>A monitor should not assign values to variables or wires in the SystemVerilog interface.</p> </li> <li> <p>Use concurrent assertions and cover property in interfaces for protocol checking and related coverage collection.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#transactions","title":"Transactions","text":"<ul> <li> <p>Create user-defined transaction classes by extending the class <code>uvm_sequence_item</code>.</p> </li> <li> <p>Try to minimize the number of distinct transaction classes.</p> </li> <li> <p>Register the transaction class with the factory using the macro <code>`uvm_object_utils</code> as the first line within the class.</p> </li> <li> <p>Do not use field macros.</p> </li> <li> <p>After the factory registration macro, declare any member variables (using the prefix <code>m_</code> as a naming convention).</p> </li> <li> <p>Use the <code>rand</code> qualifier in front of any class member variables that might need to be randomized, now or in the future.</p> </li> <li> <p>After any member variables, define a constructor that includes a single string name argument with a default value of the empty string, a call to <code>super.new</code>, and is otherwise empty.</p> <pre><code>function new (string name = \"\");\n  super.new(name);\nendfunction\n</code></pre> </li> <li> <p>After the constructor, always override the <code>convert2string</code>, <code>do_copy</code>, <code>do_compare</code>, <code>do_print</code>, and <code>do_record</code> methods.</p> </li> <li> <p>Consider overriding the <code>do_pack</code> and <code>do_unpack</code> methods.</p> </li> <li> <p>When overriding <code>do_pack</code> and <code>do_unpack</code>, use the packing and unpacking macros (e.g. <code>`uvm_pack_int</code>) where they will simplify the code.</p> </li> <li> <p>When overriding do_record, use the recording macros (e.g. <code>uvm_record_attribute` and</code>uvm_record_field`) where they will simplify the code.</p> </li> <li> <p>When overriding the <code>do_print</code>, <code>do_record</code>, <code>do_compare</code>, and do_pack methods methods, do not make use of the printer, recorder, comparer, and packer policy object arguments to those methods within the body of the overridden method.</p> </li> <li> <p>Always instantiate transaction objects using the factory.</p> <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre> </li> <li> <p>In general, the string name of the transaction should be the same as the variable name.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#sequences","title":"Sequences","text":"<ul> <li> <p>Create user-defined sequence classes by extending the class <code>uvm_sequence</code>, parameterized with the type of the transaction to be generated by the sequence.</p> </li> <li> <p>Register the sequence class with the factory using the macro <code>`uvm_object_utils</code> as the first line within the class.</p> </li> <li> <p>After the factory registration macro, declare any member variables (using the prefix <code>m_</code> as a naming convention).</p> </li> <li> <p>Use the <code>rand</code> qualifier in front of any class member variables that might need to be randomized, now or in the future.</p> </li> <li> <p>After the member variables (if any), define a constructor that includes a single string name argument with a default value of the empty string, a call to <code>super.new</code>, and is otherwise empty.</p> <pre><code>function new (string name = \"\");\n  super.new(name);\nendfunction\n</code></pre> </li> <li> <p>Any housekeeping code associated with the execution of a sequence, such as raising and lowering objections, should be placed in the <code>pre_start</code> and <code>post_start</code> methods of the sequence.</p> </li> <li> <p>When generating transactions from the body task of a sequence, do so using procedural code with the following general pattern:</p> <pre><code>req = tx_type::type_id::create(\"req\");\nstart_item(req);\nif ( !req.randomize() ) begin\n...\nend\nfinish_item(req);\n</code></pre> </li> <li> <p>Do not use the <code>`uvm_do</code> family of macros.</p> </li> <li> <p>Use the built-in transaction variables <code>req</code> and <code>rsp</code> within a sequence, unless there is a specific reason to choose different variable names.</p> </li> <li> <p>Only generate sequence items (transactions) from UVM sequences, not from ad hoc classes and not from UVM components.</p> </li> <li> <p>Always instantiate sequence objects using the factory. Instantiations should take the form:</p> <pre><code>seq_name = sequence_type::type_id::create(\"seq_name\");\n</code></pre> </li> <li> <p>The string name of each sequence object should be the same as the variable name.</p> </li> <li> <p>When creating a sequence object, always call the randomize method of the sequence object before starting the sequence.</p> </li> <li> <p>Start sequences procedurally by calling their start method.</p> <pre><code>seq_name = sequence_type::type_id::create(\"seq_name\");\nif ( !seq_name.randomize() with { ... } )\n  `uvm_error( ... )\nseq_name.start(sequencer);\n</code></pre> </li> <li> <p>Only override the <code>pre_do</code>, <code>mid_do</code>, and/or <code>post_do</code> callbacks of a sequence class as a way to modify the behavior of a pre-existing \"immutable\" sequence class.</p> </li> <li> <p>Use the macro <code>uvm_declare_p_sequencer</code> to declare a variable <code>p_sequencer</code> in situations where a sequence needs access to the sequencer on which it is running.</p> </li> <li> <p>Where a sequence needs access to a sequencer other than the sequencer on which it is itself running, add a member variable to the sequence object and assign that variable to refer to the other sequencer before starting the sequence.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#stimulus-and-phasing","title":"Stimulus and Phasing","text":"<ul> <li> <p>Use a virtual sequence to coordinate the behavior of multiple agents.</p> </li> <li> <p>Virtual sequences should be started on the null sequencer.</p> </li> <li> <p>Have a top-level sequence running on each agent that selects between all permissible child sequences at random.</p> </li> <li> <p>Keep sequences as generic as possible. Avoid writing directed sequences except where absolutely necessary.</p> </li> <li> <p>Sequences should not be phase-aware.</p> </li> <li> <p>Do override the run-time phase methods <code>reset_phase</code>, <code>configure_phase</code>, <code>main_phase</code>, <code>shutdown_phase</code> to generate stimulus, typically by starting sequences, but never in a driver, monitor, subscriber, or scoreboard component.</p> </li> <li> <p>Do introduce user-defined run-time phases where the above predefined run-time phase methods are inappropriately named or would cause confusion.</p> </li> <li> <p>When integrating multiple environments that each override the predefined or user-defined run-time phase methods, take care to order the phases correctly by introducing phase domains and synchronizing phases across domains.</p> </li> <li> <p>Do not override the predefined pre- and post- phase methods (e.g. <code>pre_reset_phase</code>), but reserve these phase for use when synchronizing phases across domains.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#objections","title":"Objections","text":"<ul> <li> <p>Determine when to end the test by raising and dropping objections in any classes that may need to extend the test while they complete some processing. (This rule has changed significantly since the first preliminary release of these guidelines.)</p> </li> <li> <p>Call the <code>set_propagate_mode(0)</code> method of every objection (UVM 1.2 onward) to disable the hierarchical propagation of that objection</p> </li> <li> <p>Consider the simulation speed impact of raising and dropping objections in inner loops, e.g. for individual transactions. Remove objections from inner loops if the simulation speed penalty is significant.</p> </li> <li> <p>Where a sequence is to raise and drop objections, it should call <code>raise_objection</code> in its <code>pre_start</code> method and <code>drop_objection</code> in its <code>post_start</code> method.</p> </li> <li> <p>Always perform the test if <code>(starting_phase != null)</code> before calling <code>raise_objection</code> or <code>drop_objection</code> within a sequence.</p> </li> <li> <p>When starting a sequence that can raise and drop objections, if you want the sequence to raise and drop objections, set the <code>starting_phase</code> member of the sequence object before starting the sequence.</p> </li> <li> <p>When calling <code>raise_objection</code> or <code>drop_objection</code>, always pass a string as a 2nd argument to describe the objection to help with debug.</p> </li> <li> <p>If the kill method of a sequence is called and the sequence can raise an objection, ensure that the <code>do_kill</code> method of the sequence is overridden to drop the objection.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#components","title":"Components","text":"<ul> <li> <p>Create user-defined component classes by extending the appropriate subclass of class <code>uvm_component</code> in order to indicate intent.</p> </li> <li> <p>Register the component class with the factory using the macro <code>`uvm_component_utils</code> as the first line within the class.</p> </li> <li> <p>After the factory registration macro, declare any ports, exports and virtual interfaces</p> </li> <li> <p>After the ports, exports, and virtual interfaces, declare any member variables (using the prefix <code>m_</code> as a naming convention).</p> </li> <li> <p>After any member variables, define a constructor that includes string name and parent arguments with no default values and a call to <code>super.new</code>.</p> <pre><code>function new (string name, uvm_component parent);\n  super.new(name, parent);\nendfunction\n</code></pre> </li> <li> <p>Instantiate any components from the <code>build_phase</code> method.</p> </li> <li> <p>Always instantiate components using the factory.</p> <pre><code>var_name = component_type::type_id::create(\"var_name\", this);\n</code></pre> </li> <li> <p>The string name of the component should be the same as the variable name.</p> </li> <li> <p>The second argument to create should be the reserved word <code>this</code>.</p> </li> <li> <p>Where a user-defined component class extends another user-defined component class, care should be taken to insert calls of the form <code>super.&lt;phase_name&gt;_phase</code> wherever appropriate, that is, where the corresponding base class phase method performs some action.</p> </li> <li> <p>Where a user-defined component class directly extends a class from the UVM base class library and overrides the standard <code>build_phase</code> method, do not call <code>super.build_phase</code>.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#connection-to-the-dut","title":"Connection to the DUT","text":"<ul> <li> <p>Use one SystemVerilog interface instance per DUT interface.</p> </li> <li> <p>Use virtual interfaces to access the SystemVerilog interface instances from the UVM verification environment.</p> </li> <li> <p>Encapsulate virtual interfaces inside a configuration object in the configuration database.</p> </li> <li> <p>Copy virtual interfaces from the top-level configuration object to the configuration objects associated with agents or lower-level envs in the <code>build_phase</code> method of the top-level env.</p> </li> <li> <p>An agent should check that its virtual interface has been set.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#tlm","title":"TLM","text":"<ul> <li> <p>Make TLM port/export connections and assign virtual interfaces in the <code>connect_phase</code> method.</p> </li> <li> <p>Communicate between UVM components using ports and exports, including analysis ports and exports where appropriate.</p> </li> <li> <p>Use analysis ports and analysis exports (or objects of class <code>uvm_subscriber</code>) when making one-to- many connections between UVM components.</p> </li> <li> <p>When making peer-to-peer connections between components, connect a port (or analysis port) directly to an export (or analysis export) without any intervening FIFO.</p> </li> <li> <p>Communicate with an agent in one of two ways: either connect the analysis port of the agent to a subscriber or access the sequencer within the agent using a direct object reference from outside.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#configurations","title":"Configurations","text":"<ul> <li> <p>Use the configuration database uvm_config_db rather than the resource database <code>uvm_resource_db</code>.</p> </li> <li> <p>Group the configuration parameters for a given component into a configuration object and set that configuration object into the configuration database.</p> </li> <li> <p>The top-level configuration object should contain references to any lower-level configuration objects.</p> </li> <li> <p>Create user-defined configuration classes by extending the class <code>uvm_object</code>.</p> </li> <li> <p>Use the class name <code>&lt;component_class&gt;_config</code> or <code>&lt;sequence_class&gt;_config</code> for the configuration class associated with a component or a sequence, respectively, where <code>&lt;component_class&gt;</code> is the class name of the component and <code>&lt;sequence_class&gt;</code> is the class name of the sequence.</p> </li> <li> <p>Use the field name <code>\"config\"</code> for the configuration object in the configuration database.</p> </li> <li> <p>Do not register user-defined configuration classes with the factory.</p> </li> <li> <p>A component should typically get and set configuration parameters (typically configuration objects) in its <code>build_phase</code> method, as opposed to any other phase methods.</p> </li> <li> <p>Always check the bit returned from <code>uvm_config_db#(T)::get</code> to ensure that the configuration parameter exists in the configuration database.</p> </li> <li> <p>A sensible default value should be chosen if <code>uvm_config_db#(T)::get</code> returns 0.</p> </li> <li> <p>Each component should get the configuration object associated with that specific component instance, and should not get the configuration object of any other component instance.</p> </li> <li> <p>The configuration object associated with any given component instance should be set by its parent or by some other direct ancestor of that component instance, and not by any other component instance.</p> </li> <li> <p>Avoid using an absolute hierarchical path name as the 2nd argument to <code>uvm_config_db#T(T)::set</code>, and provide the shortest possible unique path name.</p> </li> <li> <p>A component instance may be associated with one configuration object or with no configuration object, and several component instances may be associated with the same configuration object.</p> </li> <li> <p>For an agent, include a variable is_active in the configuration object to determine whether the agent is active or passive. Override the virtual <code>get_is_active</code> method to return this value. Check <code>get_is_active</code> before creating and connecting the sequencer and driver within the agent.</p> </li> <li> <p>If a sequence is to be parameterized, the parameters for the sequence should be put into a configuration object in the configuration database. The configuration object should be associated with the sequencer on which the sequence is to run.</p> </li> <li> <p>Any configuration object associated with a sequence should be got from the configuration database at the start of the sequence and a variable in the sequence object should be assigned to refer to that configuration object.</p> </li> <li> <p>If a component directly assigns the values of variables (including virtual interfaces) in its child components, it should do so in its build_phase method after creating those child components.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#the-factory","title":"The Factory","text":"<ul> <li> <p>Always instantiate transaction, sequence, and component objects using the factory.</p> <pre><code>// Objects\nvar_name = type_name::type_id::create(\"var_name\");\n\n// Components\nvar_name = type_name::type_id::create(\"var_name\", this);\n</code></pre> </li> <li> <p>When using a factory override to substitute a transaction, sequence, or component object with another object whose class extends the class of the original, the factory override should take one of these forms:</p> <pre><code>old_type_name::type_id::set_type_override( new_type_name::get_type() );\nold_type_name::type_id::set_inst_override( new_type_name::get_type() ... );\n</code></pre> </li> <li> <p>Call the static method <code>uvm_factory::get()</code> when you need access to the factory.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#tests","title":"Tests","text":"<ul> <li> <p>Do not generate stimulus directly from the test, but use the test to set configuration parameters and factory overrides.</p> </li> <li> <p>Set up the fixed aspects of the verification environment and generate default stimulus in the env class, not the test class, so that the env will run even with an empty test.</p> </li> <li> <p>Where appropriate, use test base classes to define structure and behavior that is common across a set of tests, and create individual tests by extending these base classes.</p> </li> <li> <p>For reuse, avoid making tests dependent on the specific details of the verification environment.</p> </li> <li> <p>For reuse, avoid making tests dependent on the specific details of the verification environment.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#messaging","title":"Messaging","text":"<ul> <li> <p>To report a message, always use one of the eight standard report macros <code>uvm_info`,</code>uvm_info_context`, and so forth, rather than ad hoc $display statements or similar.</p> </li> <li> <p>Set the message id either to a static string or to <code>get_type_name()</code>.</p> </li> <li> <p>Set message verbosity levels thoughtfully, methodically, and consistently throughout the code to avoid unnecessary data in the simulation log file and to differentiate between messages intended for use during the development and debug of the verification environment itself and messages intended for use when running tests and debugging the DUT.</p> </li> <li> <p>By default, set the verbosity level of each message to a high number such that the message is less likely to be reported, rather than to a low number such that the message is always reported.</p> </li> <li> <p>Set message severity levels thoughtfully to differentiate between messages that are purely informational, messages that may represent errors, and messages that are certainly errors.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#register-layer","title":"Register Layer","text":"<ul> <li> <p>If you use a generator to create the SystemVerilog code for the register model, do not modify the generated code.</p> </li> <li> <p>The top-level UVM environment should instantiate the register block using the factory and should call the build method of the register model.</p> </li> <li> <p>In the case of a hierarchically organized UVM environment where child environments use register models, there should be a single top-level register block that instantiates the register blocks associated with the child environments, and so on down the hierarchy.</p> </li> <li> <p>Any UVM environment that uses a register model should have a variable named <code>regmodel</code> that stores a reference to the register block for that specific environment.</p> </li> <li> <p>A UVM environment that has a register model should set the <code>regmodel</code> variable of any child component that also uses a register model to the corresponding sub-block of its register block.</p> </li> <li> <p>A UVM environment should only instantiate a register block if the value of the environment's <code>regmodel</code> variable is <code>null</code>.</p> </li> <li> <p>The variable name and the UVM instance name of each child register block in the register model itself should correspond to the name of the associated agent.</p> </li> <li> <p>A register block should only model DUT registers that are accessible by the UVM sequences associated with the immediately enclosing UVM environment.</p> </li> <li> <p>A UVM environment that uses a register model and that instantiates an agent should instantiate and connect a register adapter and a register predictor for that agent.</p> </li> <li> <p>A register model should use explicit prediction to keep its mirror values synchronized with the register values in the DUT.</p> </li> <li> <p>A register sequence that reads or write registers in a register model should extend uvm_sequence and should have a variable named <code>regmodel</code> that stores a reference to the corresponding register block.</p> </li> <li> <p>Before starting a sequence that reads or writes registers, set the regmodel variable of that sequence.</p> </li> </ul>"},{"location":"uvm/guidelines/coding-guidelines/#functional-coverage","title":"Functional Coverage","text":"<ul> <li> <p>Collect functional coverage in the UVM verification environment using the SystemVerilog <code>covergroup</code> construct.</p> </li> <li> <p>Where appropriate, collect functional coverage information in SystemVerilog interfaces using the cover property statement.</p> </li> <li> <p>Either place a covergroup in a class as an embedded covergroup or place a covergroup in a package and parameterize the covergroup so that it can be instantiated from classes in that package.</p> </li> <li> <p>Covergroups should be instantiated within UVM component classes as opposed to within transaction or sequence classes.</p> </li> <li> <p>Covergroups should be instantiated within UVM subscribers or scoreboards that are themselves instantiated within a UVM environment class and are connected to the analysis ports of monitors/agents.</p> </li> <li> <p>Instantiate the covergroup in the constructor of the coverage collector class.</p> </li> <li> <p>In order to collect functional coverage information for internal signals within the DUT, encapsulate references to hierarchical paths to the DUT in a single SystemVerilog module (or interface), then access that module from the UVM environment using a virtual interface and SystemVerilog interface in the usual way.</p> </li> <li> <p>Where coverage collection spans multiple DUT interfaces and thus depends on analysis transactions received from more than one agent, use the <code>`uvm_analysis_imp_decl</code> macro to provide multiple analysis exports in the coverage collector class.</p> </li> <li> <p>Group coverpoints into multiple covergroups in order to separate coverage of specification features from coverage of implementation features.</p> </li> <li> <p>Use a variable coverage_enable within the configuration object of the coverage collector to enable or disable coverage collection.</p> </li> <li> <p>Sample covergroups by calling their sample method as opposed to specifying a clocking event for the covergroup.</p> </li> <li> <p>Do not sample covergroups more frequently than necessary. Consider using a conditional expression iff (expression) with each coverpoint to reduce the sampling frequency.</p> </li> <li> <p>Sample values within the DUT or at the outputs of the DUT. Do not sample the stimulus applied to the inputs of the DUT. Sample DUT registers when the register value is changed by the DUT, not when it is changed directly by the stimulus.</p> </li> <li> <p>Consider setting the <code>option.at_least</code> of each covergroup and coverpoint to some value other than the default value of 1.</p> </li> <li> <p>Do not set <code>option.weight</code> or <code>option.goal</code> of a covergroup or coverpoint.</p> </li> <li> <p>Design coverpoint bins carefully to ensure that functionally significant cases are covered.</p> </li> <li> <p>When designing coverpoints, specify any illegal values or values to be excluded for coverage as <code>ignore_bins</code>. Do not use <code>illegal_bins</code>.</p> </li> </ul>"},{"location":"uvm/guidelines/resource-guide/","title":"Resource Guide","text":""},{"location":"uvm/guidelines/resource-guide/#sites","title":"Sites","text":"<ul> <li>Siemens Verification Academy<ul> <li>UVM Cookbook pdf | online</li> <li>Coverage Cookbook pdf | online</li> <li>UVM Guidelines</li> <li>UVM Tracks Videos</li> <li>UVM 1.2 Class Reference HTML</li> </ul> </li> <li>ClueLogic</li> <li>Doulos UVM<ul> <li>Easier UVM</li> <li>Easier UVM Coding Guidelines</li> <li>Easier UVM Code Generator | Reference Guide</li> <li>UVM 1.2 Class Reference HTML</li> </ul> </li> <li>Accellera<ul> <li>UVM 1.2 User Guide</li> <li>UVM 1.2 Class Reference</li> <li>UVM 1.2 Class Library Code</li> <li>SystemRDL 2.0 Register Description Language</li> </ul> </li> <li>ChipVerify</li> <li>VLSI Verify</li> <li>Learn UVM Verification</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#coding-style-guides","title":"Coding Style Guides","text":"<ul> <li>lowRISC Verilog Coding Style Guide</li> <li>Style Guide for SystemVerilog Code</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#youtube","title":"YouTube","text":"<ul> <li>Doulos: Easier UVM Video Tutorial</li> <li>Doulos: The Finer Points of UVM Sequences (Recorded Webinar)</li> <li>Aldec: Do not be afraid of UVM</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#cadence","title":"Cadence","text":"<ul> <li>Verilog Language and Applications</li> <li>SystemVerilog for Design and Verification</li> <li>Essential SystemVerilog for UVM</li> <li>SystemVerilog Accelerated Verification with UVM</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#synopsys","title":"Synopsys","text":"<ul> <li>Language: System Verilog for RTL Design</li> <li>Language: SystemVerilog Testbench</li> <li>Language: System Verilog Verification using UVM</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#articles","title":"Articles","text":"<ul> <li>UVM Rapid Adoption: A Practical Subset of UVM pdf</li> <li>UVM Rapid Adoption: A Practical Subset of UVM presentation</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#thesis","title":"Thesis","text":"<ul> <li>Automated UVM Testbench Generation Using EMF</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#books","title":"Books","text":"<ul> <li>The UVM Primer by Ray Salemi<ul> <li>GitHub repository of the book</li> </ul> </li> <li>SystemVerilog for Design Second Edition: A Guide to Using SystemVerilog for Hardware Design and Modeling by Stuart Sutherland</li> <li>SystemVerilog for Verification: A Guide to Learning the Testbench Language Features by Chris Spear</li> <li>Practical UVM: Step by Step Examples by Srivatsa Vasudevan<ul> <li>GitHub repository of the book</li> </ul> </li> <li>Design Patterns: Elements of Reusable Object-Oriented Software by Erich Gamma</li> <li>A Practical Guide to Adopting the Universal Verification Methodology (UVM) by Sharon Rosenberg</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#ieee","title":"IEEE","text":"<ul> <li>1364-2005 - IEEE Standard for Verilog Hardware Description Language</li> <li>1800-2017 - IEEE Standard for SystemVerilog Unified Hardware Design, Specification, and Verification Language</li> <li>1800-2023 - IEEE Standard for SystemVerilog Unified Hardware Design, Specification, and Verification Language</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#blogs","title":"Blogs","text":"<ul> <li>How I Learned UVM Verification: A Resource Guide</li> <li>Verification Gentleman Blog</li> <li>Sintenix</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#linters-and-formatters","title":"Linters and Formatters","text":"<ul> <li>Verible</li> <li>Verilator</li> <li>How to Install Verible: Google's SystemVerilog Tool</li> </ul>"},{"location":"uvm/guidelines/resource-guide/#extras","title":"Extras","text":"<ul> <li>Wavedrom</li> <li>DSim</li> <li>EDA Playground</li> <li>Vivado</li> </ul>"},{"location":"uvm/ral/adapter/","title":"Adapter","text":""},{"location":"uvm/ral/adapter/#summary","title":"Summary","text":"<p>The UVM Sequence Item is the base class for user-defined transactions that leverage the stimulus generation and control capabilities of the sequence-sequencer mechanism.</p>"},{"location":"uvm/ral/adapter/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once.</li> <li>Create user-defined transaction classes by extending the class <code>uvm_sequence_item</code>.</li> <li>Do not use field macros. (This comes at a heavy cost in terms of performance)</li> <li>Use the <code>rand</code> qualifier in front of any class member variables that might need to be randomized, now or in the future.</li> <li>After any member variables, define a constructor that includes a single string name argument with a default value of the empty string, a call to <code>super.new</code>, and is otherwise empty.</li> <li>After the constructor, always override the <code>convert2string</code>, <code>do_copy</code>, <code>do_compare</code>, <code>do_print</code>, and <code>do_record</code> methods.</li> <li>Always instantiate transaction objects using the factory. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/ral/adapter/#code-example","title":"Code Example","text":"sequence_item.sv<pre><code>`ifndef GPIO_UVC_SEQUENCE_ITEM_SV\n`define GPIO_UVC_SEQUENCE_ITEM_SV\n\nclass gpio_uvc_sequence_item extends uvm_sequence_item;\n\n  `uvm_object_utils(gpio_uvc_sequence_item)\n\n  rand gpio_uvc_data_t       gpio_pin;\n  rand gpio_uvc_item_type_e  trans_type;\n  rand gpio_uvc_item_delay_e delay_enable;\n  rand int unsigned          delay_duration_ps;\n\n  extern function new(string name = \"\");\n\n  extern function void do_copy(uvm_object rhs);\n  extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);\n  extern function void do_print(uvm_printer printer);\n  extern function string convert2string();\n\n  // IMPORTANT -timescale=1ps/100fs to avoid Verdi errors\n  constraint delay_c {\n    soft delay_duration_ps inside {[1_000 : 10_000]};  // 1ns - 10ns\n  }\n\nendclass : gpio_uvc_sequence_item\n\n\nfunction gpio_uvc_sequence_item::new(string name = \"\");\n  super.new(name);\nendfunction : new\n\n\nfunction void gpio_uvc_sequence_item::do_copy(uvm_object rhs);\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  super.do_copy(rhs);\n  gpio_pin = rhs_.gpio_pin;\n  trans_type = rhs_.trans_type;\n  delay_enable = rhs_.delay_enable;\n  delay_duration_ps = rhs_.delay_duration_ps;\nendfunction : do_copy\n\n\nfunction bit gpio_uvc_sequence_item::do_compare(uvm_object rhs, uvm_comparer comparer);\n  bit result;\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  result = super.do_compare(rhs, comparer);\n  result &amp;= (gpio_pin == rhs_.gpio_pin);\n  return result;\nendfunction : do_compare\n\n\nfunction void gpio_uvc_sequence_item::do_print(uvm_printer printer);\n  if (printer.knobs.sprint == 0) `uvm_info(get_type_name(), convert2string(), UVM_MEDIUM)\n  else printer.m_string = convert2string();\nendfunction : do_print\n\n\nfunction string gpio_uvc_sequence_item::convert2string();\n  string s;\n  s = super.convert2string();\n  $sformat(s, \"gpio_pin = 'd%5d, 'h%4h\", gpio_pin, gpio_pin);\n  if (delay_enable == GPIO_UVC_ITEM_DELAY_ON) begin\n    s = {s, $sformatf(\", delay_enable: %5d, delay_duration_ps: %5d\", delay_enable, delay_duration_ps)};\n  end\n  return s;\nendfunction : convert2string\n\n`endif // GPIO_UVC_SEQUENCE_ITEM_SV\n</code></pre>"},{"location":"uvm/ral/adapter/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_sequence_item</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>UVM Sequences</li> <li>Sequences</li> <li>UVM Sequence Items</li> <li>Transaction Methods</li> </ul> <p>Source Code</p> <ul> <li>[Source code <code>uvm_sequence_item.svh</code>](https://github.com/edaplayground/eda-playground/blob/master/docs/_static/uvm-1.2/src/seq/uvm_sequence_item.svh```</li> </ul>"},{"location":"uvm/ral/register-layer/","title":"Register  Layer","text":""},{"location":"uvm/ral/register-layer/#summary","title":"Summary","text":"<p>The UVM register layer classes are used to create a high-level, object-oriented model for memory-mapped registers and memories in a design under verification (DUV). The UVM register layer defines several base classes that, when properly extended, abstract the read/write operations to registers and memories in a DUV. This abstraction mechanism allows the migration of verification environments and tests from block to system levels without any modifications.</p> <p>A register model is typically composed of a hierarchy of blocks that map to the design hierarchy. Blocks can contain registers, register files and memories, as well as other blocks. The register layer classes support front-door and back-door access to provide redundant paths to the register and memory implementation, and verify the correctness of the decoding and access paths, as well as increased performance after the physical access paths have been verified. Designs with multiple physical interfaces, as well as registers, register files, and memories shared across multiple interfaces, are also supported.</p> <p>Due to the large number of registers in a design and the numerous small details involved in properly configuring the UVM register layer classes, this specialization is normally done by a model generator. Model generators work from a specification of the registers and memories in a design and thus are able to provide an up-to-date, correct-by-construction register model.</p> <p>The register model is implemented using five main building blocks - the register field; the register; the memory; the register block; and the register map.</p> <p>The register field models a collection of bits that are associated with a function within a register. A field will have a width and a bit offset position within the register. A field can have different access modes such as read/write, read only or write only. A register contains one or more fields.</p> <p>A register block corresponds to a hardware block and contains one or more registers. A register block also contains one or more register maps.</p> <p>A memory region in the design is modeled by a <code>uvm_mem</code> which has a range, or size, and is contained within a register block and has an offset determined by a register map. A memory region is modeled as either read only, write only or read-write with all accesses using the full width of the data field. A <code>uvm_memory</code> does not contain fields.</p> <p>The register map defines the address space offsets of one or more registers or memories in its parent block from the point of view of a specific bus interface. A group of registers may be accessible from another bus interface by a different set of address offsets and this can be modeled by using another address map within the parent block. The address map is also used to specify which bus agent is used when a register access takes place and which adapter is used to convert generic register transfers to/from target bus transfer <code>sequence_items</code>.</p> Layer Register base class Purpose Fields <code>uvm_reg_field</code> Bit(s) grouped according to function with a register Register <code>uvm_reg</code> Collection of fields at different bit offset Memory <code>uvm_mem</code> Represent a block of memory which extends over a specified range Block <code>uvm_block</code> Collection of registers (Hardware block level), or sub-blocks (Sub-system level) with one or more maps. May also include memories. Map <code>uvm_map</code> Named address map which locates the offset address of registers, memories or sub-blocks. Also defines the target sequencer for register access from the map."},{"location":"uvm/ral/register-layer/#register-fields","title":"Register Fields","text":"<p>The bottom layer is the field which corresponds to one or more bits within a register. Each field definition is an instantiation of the <code>uvm_reg_field</code> class. Fields are contained within an <code>uvm_reg</code> class and they are constructed and then configured using the <code>configure()</code> method:</p> <pre><code>//\n// uvm_field configure method prototype\n//\nfunction void configure(\n  uvm_reg        parent,                 // The containing register\n  int unsigned   size,                   // How many bits wide\n  int unsigned   lsb_pos,                // Bit offset within the register\n  string         access,                 // \"RW\", \"WRC\", \"WRS\", \"WO\", \"W1\", or \"WO1\"\n  bit            volatile,               // Volatile if bit is updated by hardware\n  uvm_reg_data_t reset,                  // The reset value\n  bit            has_reset,              // Whether the bit is reset\n  bit            is_rand,                // Whether the bit can be randomized\n  bit            individually_accessible // i.e. Totally contained within a byte lane\n);                         \n</code></pre>"},{"location":"uvm/ral/register-layer/#registers","title":"Registers","text":"<p>Registers are modeled by extending the <code>uvm_reg</code> class which is a container for field objects. The overall characteristics of the register are defined in its constructor method:</p> <pre><code>//\n// uvm_reg constructor prototype:\n//\nfunction new (\n  string name=\"\",      // Register name\n  int unsigned n_bits, // Register width in bits\n  int has_coverage     // Coverage model supported by the register\n);\n</code></pre> <p>The register class contains a <code>build()</code> method which is used to <code>create()</code> and <code>configure()</code> the fields. Note that this build method is not called by the UVM build phase, since the register is an uvm_object rather than an <code>uvm_component</code>.</p> <p>The following code example shows how a register model is put together.</p> <pre><code>// Reg - tdc_reg\nclass tdc_reg extends uvm_reg;\n    `uvm_object_utils(tdc_reg)\n    rand uvm_reg_field ctrl1;\n    rand uvm_reg_field adj1;\n    rand uvm_reg_field pixon;\n    rand uvm_reg_field feon;\n\n    function new(string name = \"tdc_reg\");\n        super.new(name, 8, UVM_NO_COVERAGE);\n    endfunction : new\n\n    virtual function void build();\n        this.ctrl1 = uvm_reg_field::type_id::create(\"ctrl1\");\n        this.ctrl1.configure(this, 4, 0, \"RW\", 0, 'hf, 1, 1, 0);\n        this.adj1 = uvm_reg_field::type_id::create(\"adj1\");\n        this.adj1.configure(this, 2, 4, \"RW\", 0, 'h1, 1, 1, 0);\n        this.pixon = uvm_reg_field::type_id::create(\"pixon\");\n        this.pixon.configure(this, 1, 6, \"RW\", 0, 'h0, 1, 1, 0);\n        this.feon = uvm_reg_field::type_id::create(\"feon\");\n        this.feon.configure(this, 1, 7, \"RW\", 0, 'h0, 1, 1, 0);\n    endfunction : build\nendclass : tdc_reg\n</code></pre> <p>When a register is added to a block it is created, causing its fields to be created and configured, and then it is configured before it is added to one or more <code>reg_maps</code> to define its memory offset.</p> <p>The prototype for the register <code>configure()</code> method is as follows:</p> <pre><code>//\n// Register configure method prototype\n//\nfunction void configure (\n  uvm_reg_block blk_parent,           // The containing reg block\n  uvm_reg_file regfile_parent = null, // Optional, not used\n  string hdl_path = \"\"                // Used if HW register can be specified in one\n);                                    // hdl_path string\n</code></pre>"},{"location":"uvm/ral/register-layer/#memories","title":"Memories","text":"<p>Memories are modeled by extending the <code>uvm_mem</code> class. The register model treats memories as regions, or memory address ranges where accesses can take place. Unlike registers, memory values are not stored because of the workstation memory overhead involved.</p> <p>The range and access type of the memory is defined via its constructor:</p> <pre><code>//\n// uvm_mem constructor prototype:\n//\nfunction new (\n  string           name,                           // Name of the memory model\n  longint unsigned size,                           // The address range\n  int unsigned     n_bits,                         // The width of the memory in bits\n  string           access = \"RW\",                  // Access - one of \"RW\" or \"RO\"\n  int              has_coverage = UVM_NO_COVERAGE  // Functional coverage\n);\n</code></pre> <p>An example of a memory class implementation:</p> <pre><code>// Memory array 1 - Size 32'h2000;\nclass mem_model extends uvm_mem;\n\n`uvm_object_utils(mem_model)\n\nfunction new(string name = \"mem_model\");\n  super.new(name, 32'h2000, 32, \"RW\", UVM_NO_COVERAGE);\nendfunction\n\nendclass: mem_model\n</code></pre>"},{"location":"uvm/ral/register-layer/#register-maps","title":"Register Maps","text":"<p>The purpose of the register map is two fold. The map provides information on the offset of the registers, memories and/or register blocks contained within it. The map is also used to identify which bus agent register based sequences will be executed on, however this part of the register maps functionality is set up when integrating the register model into an UVM testbench.</p> <p>In order to add a register or a memory to a map, the <code>add_reg()</code> or <code>add_mem()</code> methods are used. The prototypes for these methods are very similar:</p> <pre><code>//\n// uvm_reg_map add_reg method prototype:\n//\nfunction void add_reg (\n  uvm_reg           rg,             // Register object handle\n  uvm_reg_addr_t    offset,         // Register address offset\n  string            rights = \"RW\",  // Register access policy\n  bit               unmapped=0,     // If true, register does not appear in the address\n                                    // map and a frontdoor access needs to be defined\n  uvm_reg_frontdoor frontdoor=null  // Handle to register frontdoor access object\n);\n</code></pre> <pre><code>//\n// uvm_reg_map add_mem method prototype:\n//\nfunction void add_mem (\n  uvm_mem        mem,               // Memory object handle\n  uvm_reg_addr_t offset,            // Memory address offset\n  string         rights = \"RW\",     // Memory access policy\n  bit            unmapped=0,        // If true, memory is not in the address map\n                                    // and a frontdoor access needs to be defined\n  uvm_reg_frontdoor frontdoor=null  // Handle to memory frontdoor access object\n);\n</code></pre> <p>There can be several register maps within a block, each one can specify a different address map and a different target bus agent.</p>"},{"location":"uvm/ral/register-layer/#register-blocks","title":"Register Blocks","text":"<p>The next level of hierarchy in the UVM register structure is the <code>uvm_reg_block</code>. This class can be used as a container for registers and memories at the block level, representing the registers at the hardware functional block level, or as a container for multiple blocks representing the registers in a hardware sub-system or a complete SoC organized as blocks.</p> <p>In order to define register and memory address offsets the block contains an address map object derived from <code>uvm_reg_map</code>. A register map has to be created within the register block using the create_map method:</p> <pre><code>//\n// Prototype for the create_map method\n//\nfunction uvm_reg_map create_map(\n  string name,               // Name of the map handle\n  uvm_reg_addr_t base_addr,  // The maps base address\n  int unsigned n_bytes,      // Map access width in bytes\n  uvm_endianness_e endian,   // The endianess of the map\n  bit byte_addressing=1      // Whether byte_addressing is supported\n);                         \n\n//\n// Example:\n//\nAHB_map = create_map(\"AHB_map\", 'h0, 4, UVM_LITTLE_ENDIAN);\n</code></pre> <p>Endianness refers to the order in which bytes of a multi-byte data value (such as a 32-bit or 64-bit number) are stored in memory. There are two primary forms:</p> <ul> <li> <p>Little Endian:</p> <p>In little endian systems, the least significant byte (the \u201csmallest\u201d part of the number) is stored at the lowest memory address (i.e., first in the sequence). For example, the hexadecimal number <code>0x12345678</code> would be stored in memory as:  <code>78 56 34 12</code>.</p> </li> <li> <p>Big Endian:</p> <p>In big endian systems, the most significant byte is stored at the lowest memory address (i.e., first in the sequence). In the same example, <code>0x12345678</code> would be stored as: <code>12 34 56 78</code>.</p> </li> </ul> <p>Endianness is critical when interfacing between systems (or hardware components) that might use different byte orders. A misinterpretation of byte order may lead to incorrect data values being read or written, which is particularly relevant in register mapping and hardware interfacing.</p> <p>The <code>n_bytes</code> parameter is the word size (bus width) of the bus to which the map is associated. If a register's width exceeds the bus width, more than one bus access is needed to read and write that register over that bus. The <code>byte_addressing</code> argument affects how the address is incremented in these consecutive accesses.</p> <p>For example, if <code>n_bytes=4</code> and <code>byte_addressing=0</code>, then an access to a register that is 64-bits wide and at offset 0 will result in two bus accesses at addresses 0 and 1. With <code>byte_addressing=1</code>, that same access will result in two bus accesses at addresses 0 and 4.</p> <p>The first map to be created within a register block is assigned to the <code>default_map</code> member of the register block.</p> <p>The following code example, this declares the register class handles for each of the registers, then the <code>build()</code> method constructs and configures each of the registers before adding them to a map at the appropriate offset address:</p> <pre><code>// Addrmap - design_reg_block\nclass design_reg_block extends uvm_reg_block;\n    `uvm_object_utils(design_reg_block)\n    rand tdc_reg SET_TDC_DCO1_00;\n    rand tdc_reg SET_TDC_DCO1_01;\n    rand tdc_reg SET_TDC_DCO1_02;\n    rand tdc_reg SET_TDC_DCO1_03;\n\n    function new(string name = \"design_reg_block\");\n        super.new(name);\n    endfunction : new\n\n    virtual function void build();\n\n        this.SET_TDC_DCO1_00 = tdc_reg::type_id::create(\"SET_TDC_DCO1_00\");\n        this.SET_TDC_DCO1_00.configure(this);\n        this.SET_TDC_DCO1_00.build();\n\n        this.SET_TDC_DCO1_01 = tdc_reg::type_id::create(\"SET_TDC_DCO1_01\");\n        this.SET_TDC_DCO1_01.configure(this);\n        this.SET_TDC_DCO1_01.build();\n\n        this.SET_TDC_DCO1_02 = tdc_reg::type_id::create(\"SET_TDC_DCO1_02\");\n        this.SET_TDC_DCO1_02.configure(this);\n        this.SET_TDC_DCO1_02.build();\n\n        this.SET_TDC_DCO1_03 = tdc_reg::type_id::create(\"SET_TDC_DCO1_03\");\n        this.SET_TDC_DCO1_03.configure(this);\n        this.SET_TDC_DCO1_03.build();\n\n        this.SET_TDC_DCO1_04 = tdc_reg::type_id::create(\"SET_TDC_DCO1_04\");\n        this.SET_TDC_DCO1_04.configure(this);\n        this.SET_TDC_DCO1_04.build();\n\n        // Map name, Offset, Number of bytes, Endianess\n        this.default_map = create_map(\"reg_map\", 0, 1, UVM_NO_ENDIAN);\n\n        this.default_map.add_reg(this.SET_TDC_DCO1_00, 'h0);\n        this.default_map.add_reg(this.SET_TDC_DCO1_01, 'h1);\n        this.default_map.add_reg(this.SET_TDC_DCO1_02, 'h2);\n        this.default_map.add_reg(this.SET_TDC_DCO1_03, 'h3);\n        this.default_map.add_reg(this.SET_TDC_DCO1_04, 'h4);\n\n    endfunction : build\nendclass : mattonella_reg_block\n</code></pre>"},{"location":"uvm/ral/register-layer/#hierarchical-register-blocks","title":"Hierarchical Register Blocks","text":"<p>The cluster block incorporates each sub-block and adds them to a new cluster level address map. This process can be repeated and a full SoC register map might contain several nested layers of register blocks.</p> <p>The procedure is similar to that used for a standard register block. However, in this case, you utilize a class member of type <code>uvm_reg_block</code> instead of <code>uvm_reg</code>, and instead of using <code>add_reg()</code> you call <code>add_submap()</code>.</p> <pre><code>//\n// uvm_reg_map add_submap method prototype:\n//\nfunction void add_submap (\n  uvm_reg_map    child_map, // Name of the child map\n  uvm_reg_addr_t offset     // Offset in father reg_block\n);\n</code></pre> <p>This is an example:</p> <pre><code>package pss_reg_pkg;\n\n  import uvm_pkg::*;\n  `include \"uvm_macros.svh\"\n\n  import spi_reg_pkg::*;\n  import gpio_reg_pkg::*;\n\n  class pss_reg_block extends uvm_reg_block;\n\n  `uvm_object_utils(pss_reg_block)\n\n  rand spi_reg_block spi;\n  rand gpio_reg_block gpio;\n\n  function new(string name = \"pss_reg_block\");\n    super.new(name);\n  endfunction\n\n  function void build();\n\n    spi = spi_reg_block::type_id::create(\"spi\");\n    spi.configure(this);\n    spi.build();\n\n    gpio = gpio_reg_block::type_id::create(\"gpio\");\n    gpio.configure(this);\n    gpio.build();\n\n    AHB_map = create_map(\"AHB_map\", 0, 4, UVM_LITTLE_ENDIAN);\n    default_map = AHB_map;\n    AHB_map.add_submap(this.spi.default_map, 0);\n    AHB_map.add_submap(this.gpio.default_map, 32'h100);\n\n    lock_model();\n  endfunction: build\n\n  endclass: pss_reg_block\n\nendpackage: pss_reg_pkg\n</code></pre>"},{"location":"uvm/ral/register-layer/#functions","title":"Functions","text":"<p>This are some functions you need to know:</p> <pre><code>regmodel.lock_model();\nregmodel.default_map.set_auto_predict(0);\n</code></pre>"},{"location":"uvm/ral/register-layer/#mirroring","title":"Mirroring","text":""},{"location":"uvm/ral/register-layer/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 User Guide</li> <li>UVM 1.2 Class Reference <code>uvm_sequence_item</code></li> <li>UVM 1.2 Class Reference Index</li> <li>UVM 1.2 Global Declarations for the Register Layer</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>Register Model and Structure</li> </ul> <p>Source Code</p> <ul> <li>Source code <code>uvm_reg_field.svh</code></li> <li>Source code <code>uvm_reg.svh</code></li> <li>Source code <code>uvm_reg_block.svh</code></li> <li>Source code <code>uvm_mem.svh</code></li> <li> <p>Source code <code>uvm_reg_map.svh</code></p> </li> <li> <p>Source code <code>uvm_reg_adapter.svh</code></p> </li> <li>Source code <code>uvm_reg_predictor.svh</code></li> </ul>"},{"location":"uvm/ral/register-model/","title":"Register Model","text":""},{"location":"uvm/ral/register-model/#summary","title":"Summary","text":"<p>The UVM Sequence Item is the base class for user-defined transact</p>"},{"location":"uvm/ral/register-model/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once.</li> <li>Create user-defined transaction classes by extending the class <code>uvm_sequence_item</code>.</li> <li>Do not use field macros. (This comes at a heavy cost in terms of performance)</li> <li>Use the <code>rand</code> qualifier in front of any class member variables that might need to be randomized, now or in the future.</li> <li>After any member variables, define a constructor that includes a single string name argument with a default value of the empty string, a call to <code>super.new</code>, and is otherwise empty.</li> </ul>"},{"location":"uvm/ral/register-model/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference - Global Declarations for the Register Layer</li> <li>UVM 1.2 Class Reference <code>uvm_reg_block</code><ul> <li>UVM 1.2 Class Reference <code>uvm_reg</code><ul> <li>UVM 1.2 Class Reference <code>uvm_reg_field</code></li> </ul> </li> <li>UVM 1.2 Class Reference <code>uvm_mem</code></li> </ul> </li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>Register Package</li> <li>Register Model and Structure</li> </ul> <p>Source Code</p> <ul> <li>Source code <code>uvm_reg_model.svh</code></li> <li> <p>Source code <code>uvm_reg_block.svh</code></p> <ul> <li>Source code <code>uvm_reg.svh</code><ul> <li>Source code <code>uvm_reg_field.svh</code></li> </ul> </li> <li>Source code <code>uvm_mem.svh</code></li> </ul> </li> <li> <p>Sourece code <code>uvm_reg_sequence.svh</code></p> </li> </ul> <p>Tools</p> <ul> <li>PeakRDL Github Repository</li> <li>PeakRDL-uvm GitHub Repository</li> </ul>"},{"location":"uvm/templates/agent-config/","title":"UVM Agent Config","text":""},{"location":"uvm/templates/agent-config/#summary","title":"Summary","text":"<p>The UVM Agent Config is </p>"},{"location":"uvm/templates/agent-config/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/agent-config/#code-example","title":"Code Example","text":"sequence_item.sv<pre><code>`ifndef GPIO_UVC_SEQUENCE_ITEM_SV\n`define GPIO_UVC_SEQUENCE_ITEM_SV\n\nclass gpio_uvc_sequence_item extends uvm_sequence_item;\n\n  `uvm_object_utils(gpio_uvc_sequence_item)\n\n  rand gpio_uvc_data_t       gpio_pin;\n  rand gpio_uvc_item_type_e  trans_type;\n  rand gpio_uvc_item_delay_e delay_enable;\n  rand int unsigned          delay_duration_ps;\n\n  extern function new(string name = \"\");\n\n  extern function void do_copy(uvm_object rhs);\n  extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);\n  extern function void do_print(uvm_printer printer);\n  extern function string convert2string();\n\n  // IMPORTANT -timescale=1ps/100fs to avoid Verdi errors\n  constraint delay_c {\n    soft delay_duration_ps inside {[1_000 : 10_000]};  // 1ns - 10ns\n  }\n\nendclass : gpio_uvc_sequence_item\n\n\nfunction gpio_uvc_sequence_item::new(string name = \"\");\n  super.new(name);\nendfunction : new\n\n\nfunction void gpio_uvc_sequence_item::do_copy(uvm_object rhs);\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  super.do_copy(rhs);\n  gpio_pin = rhs_.gpio_pin;\n  trans_type = rhs_.trans_type;\n  delay_enable = rhs_.delay_enable;\n  delay_duration_ps = rhs_.delay_duration_ps;\nendfunction : do_copy\n\n\nfunction bit gpio_uvc_sequence_item::do_compare(uvm_object rhs, uvm_comparer comparer);\n  bit result;\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  result = super.do_compare(rhs, comparer);\n  result &amp;= (gpio_pin == rhs_.gpio_pin);\n  return result;\nendfunction : do_compare\n\n\nfunction void gpio_uvc_sequence_item::do_print(uvm_printer printer);\n  if (printer.knobs.sprint == 0) `uvm_info(get_type_name(), convert2string(), UVM_MEDIUM)\n  else printer.m_string = convert2string();\nendfunction : do_print\n\n\nfunction string gpio_uvc_sequence_item::convert2string();\n  string s;\n  s = super.convert2string();\n  $sformat(s, \"gpio_pin = 'd%5d, 'h%4h\", gpio_pin, gpio_pin);\n  if (delay_enable == GPIO_UVC_ITEM_DELAY_ON) begin\n    s = {s, $sformatf(\", delay_enable: %5d, delay_duration_ps: %5d\", delay_enable, delay_duration_ps)};\n  end\n  return s;\nendfunction : convert2string\n\n`endif // GPIO_UVC_SEQUENCE_ITEM_SV\n</code></pre>"},{"location":"uvm/templates/agent-config/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_sequence_item</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>UVM Sequences</li> <li>Sequences</li> <li>UVM Sequence Items</li> <li>Transaction Methods</li> </ul> <p>Source Code</p> <ul> <li>[Source code <code>uvm_sequence_item.svh</code>](https://github.com/edaplayground/eda-playground/blob/master/docs/_static/uvm-1.2/src/seq/uvm_sequence_item.svh</li> </ul>"},{"location":"uvm/templates/agent/","title":"UVM Agent","text":""},{"location":"uvm/templates/agent/#summary","title":"Summary","text":"<p>The UVM Agent is the base class for user-defined transactions that leverage the stimulus generation and control capabilities of the sequence-sequencer mechanism.</p>"},{"location":"uvm/templates/agent/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/agent/#code-example","title":"Code Example","text":"agent.sv<pre><code>`ifndef GPIO_UVC_AGENT_SV\n`define GPIO_UVC_AGENT_SV\n\nclass gpio_uvc_agent extends uvm_agent;\n\n  `uvm_component_utils(gpio_uvc_agent)\n\n  uvm_analysis_port #(gpio_uvc_sequence_item) analysis_port;\n\n  gpio_uvc_config    m_config;\n  gpio_uvc_sequencer m_sequencer;\n  gpio_uvc_driver    m_driver;\n  gpio_uvc_monitor   m_monitor;\n\n  extern function new(string name, uvm_component parent);\n\n  extern function void build_phase(uvm_phase phase);\n  extern function void connect_phase(uvm_phase phase);\n\nendclass : gpio_uvc_agent\n\n\nfunction gpio_uvc_agent::new(string name, uvm_component parent);\n  super.new(name, parent);\nendfunction : new\n\n\nfunction void gpio_uvc_agent::build_phase(uvm_phase phase);\n  if (!uvm_config_db#(gpio_uvc_config)::get(this, \"\", \"config\", m_config)) begin\n    `uvm_fatal(get_name(), \"Could not retrieve gpio_uvc_config from config db\")\n  end\n\n  if (m_config.is_active == UVM_ACTIVE) begin\n    m_sequencer = gpio_uvc_sequencer::type_id::create(\"m_sequencer\", this);\n    m_driver    = gpio_uvc_driver   ::type_id::create(\"m_driver\",    this);\n  end\n\n  m_monitor = gpio_uvc_monitor::type_id::create(\"m_monitor\", this);\n  analysis_port = new(\"analysis_port\", this);\nendfunction : build_phase\n\n\nfunction void gpio_uvc_agent::connect_phase(uvm_phase phase);\n  if (m_config.is_active == UVM_ACTIVE) begin\n    m_driver.seq_item_port.connect(m_sequencer.seq_item_export);\n  end\n\n  m_monitor.analysis_port.connect(this.analysis_port);\nendfunction : connect_phase\n\n`endif // GPIO_UVC_AGENT_SV\n</code></pre>"},{"location":"uvm/templates/agent/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_agent</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>UVM Sequences</li> <li>Sequences</li> <li>UVM Sequence Items</li> <li>Transaction Methods</li> </ul> <p>Source Code</p> <ul> <li>Source code <code>uvm_agent.svh</code></li> </ul>"},{"location":"uvm/templates/coverage/","title":"Coverage","text":""},{"location":"uvm/templates/coverage/#summary","title":"Summary","text":"<p>To understand the verification progress you need to answer the following questions:</p> <ul> <li>Were all the design features and requirements identified in the testplan verified?</li> <li>Were there lines of code or structures in the design model that were never exercised?</li> </ul> <p>Coverage is the metric we use during simulation to help us answer these questions, in other words is a simulation metric we use to measure verification progress and completeness.</p>"},{"location":"uvm/templates/coverage/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/coverage/#code-example","title":"Code Example","text":"sequence_item.sv<pre><code>`ifndef GPIO_UVC_SEQUENCE_ITEM_SV\n`define GPIO_UVC_SEQUENCE_ITEM_SV\n\nclass gpio_uvc_sequence_item extends uvm_sequence_item;\n\n  `uvm_object_utils(gpio_uvc_sequence_item)\n\n  rand gpio_uvc_data_t       gpio_pin;\n  rand gpio_uvc_item_type_e  trans_type;\n  rand gpio_uvc_item_delay_e delay_enable;\n  rand int unsigned          delay_duration_ps;\n\n  extern function new(string name = \"\");\n\n  extern function void do_copy(uvm_object rhs);\n  extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);\n  extern function void do_print(uvm_printer printer);\n  extern function string convert2string();\n\n  // IMPORTANT -timescale=1ps/100fs to avoid Verdi errors\n  constraint delay_c {\n    soft delay_duration_ps inside {[1_000 : 10_000]};  // 1ns - 10ns\n  }\n\nendclass : gpio_uvc_sequence_item\n\n\nfunction gpio_uvc_sequence_item::new(string name = \"\");\n  super.new(name);\nendfunction : new\n\n\nfunction void gpio_uvc_sequence_item::do_copy(uvm_object rhs);\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  super.do_copy(rhs);\n  gpio_pin = rhs_.gpio_pin;\n  trans_type = rhs_.trans_type;\n  delay_enable = rhs_.delay_enable;\n  delay_duration_ps = rhs_.delay_duration_ps;\nendfunction : do_copy\n\n\nfunction bit gpio_uvc_sequence_item::do_compare(uvm_object rhs, uvm_comparer comparer);\n  bit result;\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  result = super.do_compare(rhs, comparer);\n  result &amp;= (gpio_pin == rhs_.gpio_pin);\n  return result;\nendfunction : do_compare\n\n\nfunction void gpio_uvc_sequence_item::do_print(uvm_printer printer);\n  if (printer.knobs.sprint == 0) `uvm_info(get_type_name(), convert2string(), UVM_MEDIUM)\n  else printer.m_string = convert2string();\nendfunction : do_print\n\n\nfunction string gpio_uvc_sequence_item::convert2string();\n  string s;\n  s = super.convert2string();\n  $sformat(s, \"gpio_pin = 'd%5d, 'h%4h\", gpio_pin, gpio_pin);\n  if (delay_enable == GPIO_UVC_ITEM_DELAY_ON) begin\n    s = {s, $sformatf(\", delay_enable: %5d, delay_duration_ps: %5d\", delay_enable, delay_duration_ps)};\n  end\n  return s;\nendfunction : convert2string\n\n`endif // GPIO_UVC_SEQUENCE_ITEM_SV\n</code></pre>"},{"location":"uvm/templates/coverage/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_sequence_item</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>Coverage Cookbook pdf</li> </ul> <p>Source Code</p> <ul> <li>Source code <code>uvm_sequence_item.svh</code></li> </ul>"},{"location":"uvm/templates/driver/","title":"UVM Driver","text":""},{"location":"uvm/templates/driver/#summary","title":"Summary","text":"<p>The UVM Driver is</p>"},{"location":"uvm/templates/driver/#coding-guidelines","title":"Coding Guidelines","text":"<p>Coding Guidelines</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once.</li> <li>Create user-defined transaction classes by extending the class <code>uvm_sequence_item</code>.</li> <li>Do not use field macros. (This comes at a heavy cost in terms of performance)</li> <li>Use the <code>rand</code> qualifier in front of any class member variables that might need to be randomized, now or in the future.</li> <li>After any member variables, define a constructor that includes a single string name argument with a default value of the empty string, a call to <code>super.new</code>, and is otherwise empty.</li> <li>After the constructor, always override the <code>convert2string</code>, <code>do_copy</code>, <code>do_compare</code>, <code>do_print</code>, and <code>do_record</code> methods.</li> <li>Always instantiate transaction objects using the factory. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/driver/#code-example","title":"Code Example","text":"driver.sv<pre><code>`ifndef GPIO_UVC_DRIVER_SV\n`define GPIO_UVC_DRIVER_SV\n\nclass gpio_uvc_driver extends uvm_driver #(gpio_uvc_sequence_item);\n\n  `uvm_component_utils(gpio_uvc_driver)\n\n  virtual gpio_uvc_if vif;\n  gpio_uvc_config     m_config;\n\n  extern function new(string name, uvm_component parent);\n\n  extern function void build_phase(uvm_phase phase);\n  extern task run_phase(uvm_phase phase);\n  extern task drive_sync();\n  extern task drive_async();\n  extern task do_drive();\n\nendclass : gpio_uvc_driver\n\n\nfunction gpio_uvc_driver::new(string name, uvm_component parent);\n  super.new(name, parent);\nendfunction : new\n\n\nfunction void gpio_uvc_driver::build_phase(uvm_phase phase);\n  if (!uvm_config_db#(virtual gpio_uvc_if)::get(get_parent(), \"\", \"vif\", vif)) begin\n    `uvm_fatal(get_name(), \"Could not retrieve gpio_uvc_if from config db\")\n  end\n\n  if (!uvm_config_db#(gpio_uvc_config)::get(get_parent(), \"\", \"config\", m_config)) begin\n    `uvm_fatal(get_name(), \"Could not retrieve gpio_uvc_config from config db\")\n  end\nendfunction : build_phase\n\n\ntask gpio_uvc_driver::run_phase(uvm_phase phase);\n  forever begin\n    seq_item_port.get_next_item(req);\n    do_drive();\n    seq_item_port.item_done();\n  end\nendtask : run_phase\n\n\ntask gpio_uvc_driver::drive_sync();\n  @(vif.cb_drv);\n  vif.cb_drv.gpio_pin &lt;= req.gpio_pin;\n  `uvm_info(get_type_name(), {\"Sending item: \", req.convert2string()}, UVM_MEDIUM)\nendtask : drive_sync\n\n\ntask gpio_uvc_driver::drive_async();\n  vif.gpio_pin = req.gpio_pin;\n  `uvm_info(get_type_name(), {\"Sending item: \", req.convert2string()}, UVM_MEDIUM)\n  if (req.delay_enable == GPIO_UVC_ITEM_DELAY_ON) begin\n    #(req.delay_duration_ps * 1ps);\n  end else begin\n    @(vif.cb_drv);\n  end\nendtask : drive_async\n\n\ntask gpio_uvc_driver::do_drive();\n  if (req.trans_type == GPIO_UVC_ITEM_ASYNC) begin\n    drive_async();\n  end else begin\n    drive_sync();\n  end\nendtask : do_drive\n\n`endif // GPIO_UVC_DRIVER_SV\n</code></pre>"},{"location":"uvm/templates/driver/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>driver</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>Sequence API</li> <li>Sequence Driver Connection</li> <li>Driver Sequence API</li> <li>Sequence-Driver Use Models<ul> <li>Unidirectional Protocols</li> <li>Bidirectional Protocols</li> <li>Pipelined Protocols</li> </ul> </li> </ul> <p>Articles</p> <ul> <li>UVM Rapid Adoption: A Practical Subset of UVM - 3.4.6 Driver/Sequence Synchronization</li> </ul> <p>Source code</p> <ul> <li>Source code <code>uvm_driver.svh</code></li> </ul>"},{"location":"uvm/templates/env-config/","title":"UVM Environment Config","text":""},{"location":"uvm/templates/env-config/#summary","title":"Summary","text":"<p>The UVM Environment Config is </p>"},{"location":"uvm/templates/env-config/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/env-config/#code-example","title":"Code Example","text":"sequence_item.sv<pre><code>`ifndef GPIO_UVC_SEQUENCE_ITEM_SV\n`define GPIO_UVC_SEQUENCE_ITEM_SV\n\nclass gpio_uvc_sequence_item extends uvm_sequence_item;\n\n  `uvm_object_utils(gpio_uvc_sequence_item)\n\n  rand gpio_uvc_data_t       gpio_pin;\n  rand gpio_uvc_item_type_e  trans_type;\n  rand gpio_uvc_item_delay_e delay_enable;\n  rand int unsigned          delay_duration_ps;\n\n  extern function new(string name = \"\");\n\n  extern function void do_copy(uvm_object rhs);\n  extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);\n  extern function void do_print(uvm_printer printer);\n  extern function string convert2string();\n\n  // IMPORTANT -timescale=1ps/100fs to avoid Verdi errors\n  constraint delay_c {\n    soft delay_duration_ps inside {[1_000 : 10_000]};  // 1ns - 10ns\n  }\n\nendclass : gpio_uvc_sequence_item\n\n\nfunction gpio_uvc_sequence_item::new(string name = \"\");\n  super.new(name);\nendfunction : new\n\n\nfunction void gpio_uvc_sequence_item::do_copy(uvm_object rhs);\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  super.do_copy(rhs);\n  gpio_pin = rhs_.gpio_pin;\n  trans_type = rhs_.trans_type;\n  delay_enable = rhs_.delay_enable;\n  delay_duration_ps = rhs_.delay_duration_ps;\nendfunction : do_copy\n\n\nfunction bit gpio_uvc_sequence_item::do_compare(uvm_object rhs, uvm_comparer comparer);\n  bit result;\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  result = super.do_compare(rhs, comparer);\n  result &amp;= (gpio_pin == rhs_.gpio_pin);\n  return result;\nendfunction : do_compare\n\n\nfunction void gpio_uvc_sequence_item::do_print(uvm_printer printer);\n  if (printer.knobs.sprint == 0) `uvm_info(get_type_name(), convert2string(), UVM_MEDIUM)\n  else printer.m_string = convert2string();\nendfunction : do_print\n\n\nfunction string gpio_uvc_sequence_item::convert2string();\n  string s;\n  s = super.convert2string();\n  $sformat(s, \"gpio_pin = 'd%5d, 'h%4h\", gpio_pin, gpio_pin);\n  if (delay_enable == GPIO_UVC_ITEM_DELAY_ON) begin\n    s = {s, $sformatf(\", delay_enable: %5d, delay_duration_ps: %5d\", delay_enable, delay_duration_ps)};\n  end\n  return s;\nendfunction : convert2string\n\n`endif // GPIO_UVC_SEQUENCE_ITEM_SV\n</code></pre>"},{"location":"uvm/templates/env-config/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_sequence_item</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>UVM Sequences</li> <li>Sequences</li> <li>UVM Sequence Items</li> <li>Transaction Methods</li> </ul> <p>Source Code</p> <ul> <li>[Source code <code>uvm_sequence_item.svh</code>](https://github.com/edaplayground/eda-playground/blob/master/docs/_static/uvm-1.2/src/seq/uvm_sequence_item.sv`</li> </ul>"},{"location":"uvm/templates/env/","title":"UVM Environment","text":""},{"location":"uvm/templates/env/#summary","title":"Summary","text":"<p>The UVM Environment is </p>"},{"location":"uvm/templates/env/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/env/#code-example","title":"Code Example","text":"sequence_item.sv<pre><code>`ifndef GPIO_UVC_SEQUENCE_ITEM_SV\n`define GPIO_UVC_SEQUENCE_ITEM_SV\n\nclass gpio_uvc_sequence_item extends uvm_sequence_item;\n\n  `uvm_object_utils(gpio_uvc_sequence_item)\n\n  rand gpio_uvc_data_t       gpio_pin;\n  rand gpio_uvc_item_type_e  trans_type;\n  rand gpio_uvc_item_delay_e delay_enable;\n  rand int unsigned          delay_duration_ps;\n\n  extern function new(string name = \"\");\n\n  extern function void do_copy(uvm_object rhs);\n  extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);\n  extern function void do_print(uvm_printer printer);\n  extern function string convert2string();\n\n  // IMPORTANT -timescale=1ps/100fs to avoid Verdi errors\n  constraint delay_c {\n    soft delay_duration_ps inside {[1_000 : 10_000]};  // 1ns - 10ns\n  }\n\nendclass : gpio_uvc_sequence_item\n\n\nfunction gpio_uvc_sequence_item::new(string name = \"\");\n  super.new(name);\nendfunction : new\n\n\nfunction void gpio_uvc_sequence_item::do_copy(uvm_object rhs);\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  super.do_copy(rhs);\n  gpio_pin = rhs_.gpio_pin;\n  trans_type = rhs_.trans_type;\n  delay_enable = rhs_.delay_enable;\n  delay_duration_ps = rhs_.delay_duration_ps;\nendfunction : do_copy\n\n\nfunction bit gpio_uvc_sequence_item::do_compare(uvm_object rhs, uvm_comparer comparer);\n  bit result;\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  result = super.do_compare(rhs, comparer);\n  result &amp;= (gpio_pin == rhs_.gpio_pin);\n  return result;\nendfunction : do_compare\n\n\nfunction void gpio_uvc_sequence_item::do_print(uvm_printer printer);\n  if (printer.knobs.sprint == 0) `uvm_info(get_type_name(), convert2string(), UVM_MEDIUM)\n  else printer.m_string = convert2string();\nendfunction : do_print\n\n\nfunction string gpio_uvc_sequence_item::convert2string();\n  string s;\n  s = super.convert2string();\n  $sformat(s, \"gpio_pin = 'd%5d, 'h%4h\", gpio_pin, gpio_pin);\n  if (delay_enable == GPIO_UVC_ITEM_DELAY_ON) begin\n    s = {s, $sformatf(\", delay_enable: %5d, delay_duration_ps: %5d\", delay_enable, delay_duration_ps)};\n  end\n  return s;\nendfunction : convert2string\n\n`endif // GPIO_UVC_SEQUENCE_ITEM_SV\n</code></pre>"},{"location":"uvm/templates/env/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_sequence_item</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>UVM Sequences</li> <li>Sequences</li> <li>UVM Sequence Items</li> <li>Transaction Methods</li> </ul> <p>Source Code</p> <ul> <li>Source code <code>uvm_sequence_item.svh</code></li> </ul>"},{"location":"uvm/templates/interface/","title":"Interface","text":""},{"location":"uvm/templates/interface/#summary","title":"Summary","text":"<p>The Interface is</p>"},{"location":"uvm/templates/interface/#coding-guidelines","title":"Coding Guidelines","text":"<p>Coding Guidelines</p> <ul> <li>Use one SystemVerilog interface instance per DUT interface</li> </ul>"},{"location":"uvm/templates/interface/#code-example","title":"Code Example","text":"<p>The interface construct, enclosed between the keywords <code>interface...endinterface</code>, encapsulates the communication between design blocks, and between design and verification blocks, allowing a smooth migration from abstract system-level design through successive refinement down to lower level register-transfer and structural views of the design. By encapsulating the communication between blocks, the interface construct also facilitates design reuse.</p> interface.sv<pre><code>`ifndef GPIO_UVC_IF_SV\n`define GPIO_UVC_IF_SV\ninterface gpio_uvc_if (\n    input logic clk\n);\n  import gpio_uvc_pkg::*;\n  gpio_uvc_data_t gpio_pin;\n  gpio_uvc_data_t gpio_pin_passive;\n  clocking cb_drv @(posedge clk);\n    default output #1ns;\n    output gpio_pin;\n  endclocking : cb_drv\n  clocking cb_mon @(posedge clk);\n    default input #1ns;\n    input gpio_pin;\n    input gpio_pin_passive;\n  endclocking : cb_mon\nendinterface : gpio_uvc_if\n`endif // GPIO_UVC_IF_SV\n</code></pre>"},{"location":"uvm/templates/interface/#reference-material","title":"Reference Material","text":"<p>IEEE</p> <p>SystemVerilog LRM - 3.5 Interfaces</p>"},{"location":"uvm/templates/monitor/","title":"UVM Monitor","text":""},{"location":"uvm/templates/monitor/#summary","title":"Summary","text":"<p>The UVM Monitor is</p>"},{"location":"uvm/templates/monitor/#coding-guidelines","title":"Coding Guidelines","text":"<p>Coding Guidelines</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/monitor/#code-example","title":"Code Example","text":"monitor.sv<pre><code>`ifndef GPIO_UVC_MONITOR_SV\n`define GPIO_UVC_MONITOR_SV\n\nclass gpio_uvc_monitor extends uvm_monitor;\n\n  `uvm_component_utils(gpio_uvc_monitor)\n\n  uvm_analysis_port #(gpio_uvc_sequence_item) analysis_port;\n\n  virtual gpio_uvc_if                         vif;\n  gpio_uvc_config                             m_config;\n  gpio_uvc_sequence_item                      m_trans;\n\n  extern function new(string name, uvm_component parent);\n\n  extern function void build_phase(uvm_phase phase);\n  extern task run_phase(uvm_phase phase);\n  extern task do_mon();\n\nendclass : gpio_uvc_monitor\n\n\nfunction gpio_uvc_monitor::new(string name, uvm_component parent);\n  super.new(name, parent);\nendfunction : new\n\n\nfunction void gpio_uvc_monitor::build_phase(uvm_phase phase);\n  if (!uvm_config_db#(virtual gpio_uvc_if)::get(get_parent(), \"\", \"vif\", vif)) begin\n    `uvm_fatal(get_name(), \"Could not retrieve gpio_uvc_if from config db\")\n  end\n\n  if (!uvm_config_db#(gpio_uvc_config)::get(get_parent(), \"\", \"config\", m_config)) begin\n    `uvm_fatal(get_name(), \"Could not retrieve gpio_uvc_config from config db\")\n  end\n\n  analysis_port = new(\"analysis_port\", this);\nendfunction : build_phase\n\n\ntask gpio_uvc_monitor::run_phase(uvm_phase phase);\n  m_trans = gpio_uvc_sequence_item::type_id::create(\"m_trans\");\n  do_mon();\nendtask : run_phase\n\n\ntask gpio_uvc_monitor::do_mon();\n  forever begin\n    if (m_config.is_active) begin\n      @(vif.gpio_pin);\n      m_trans.gpio_pin = vif.gpio_pin &amp; m_config.get_mask();\n    end else begin\n      @(vif.gpio_pin_passive);\n      m_trans.gpio_pin = vif.gpio_pin_passive &amp; m_config.get_mask();\n    end\n    `uvm_info(get_type_name(), {\"Got item: \", m_trans.convert2string()}, UVM_MEDIUM)\n    analysis_port.write(m_trans);\n  end\nendtask : do_mon\n\n`endif // GPIO_UVC_MONITOR_SV\n</code></pre>"},{"location":"uvm/templates/monitor/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>monitor</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Monitor</li> <li>Analysis Componets and Techniques<ul> <li>Analysis Port</li> <li>Analysis Connections</li> </ul> </li> </ul> <p>Articles</p> <ul> <li>UVM Rapid Adoption: A Practical Subset of UVM - 3.5 UVM Monitors</li> </ul> <p>Source code</p> <ul> <li>Source code <code>uvm_monitor.svh</code></li> </ul>"},{"location":"uvm/templates/scoreboard/","title":"UVM Scoreboard","text":""},{"location":"uvm/templates/scoreboard/#summary","title":"Summary","text":"<p>The UVM Scoreboard is </p>"},{"location":"uvm/templates/scoreboard/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/scoreboard/#code-example","title":"Code Example","text":"sequence_item.sv<pre><code>`ifndef GPIO_UVC_SEQUENCE_ITEM_SV\n`define GPIO_UVC_SEQUENCE_ITEM_SV\n\nclass gpio_uvc_sequence_item extends uvm_sequence_item;\n\n  `uvm_object_utils(gpio_uvc_sequence_item)\n\n  rand gpio_uvc_data_t       gpio_pin;\n  rand gpio_uvc_item_type_e  trans_type;\n  rand gpio_uvc_item_delay_e delay_enable;\n  rand int unsigned          delay_duration_ps;\n\n  extern function new(string name = \"\");\n\n  extern function void do_copy(uvm_object rhs);\n  extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);\n  extern function void do_print(uvm_printer printer);\n  extern function string convert2string();\n\n  // IMPORTANT -timescale=1ps/100fs to avoid Verdi errors\n  constraint delay_c {\n    soft delay_duration_ps inside {[1_000 : 10_000]};  // 1ns - 10ns\n  }\n\nendclass : gpio_uvc_sequence_item\n\n\nfunction gpio_uvc_sequence_item::new(string name = \"\");\n  super.new(name);\nendfunction : new\n\n\nfunction void gpio_uvc_sequence_item::do_copy(uvm_object rhs);\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  super.do_copy(rhs);\n  gpio_pin = rhs_.gpio_pin;\n  trans_type = rhs_.trans_type;\n  delay_enable = rhs_.delay_enable;\n  delay_duration_ps = rhs_.delay_duration_ps;\nendfunction : do_copy\n\n\nfunction bit gpio_uvc_sequence_item::do_compare(uvm_object rhs, uvm_comparer comparer);\n  bit result;\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  result = super.do_compare(rhs, comparer);\n  result &amp;= (gpio_pin == rhs_.gpio_pin);\n  return result;\nendfunction : do_compare\n\n\nfunction void gpio_uvc_sequence_item::do_print(uvm_printer printer);\n  if (printer.knobs.sprint == 0) `uvm_info(get_type_name(), convert2string(), UVM_MEDIUM)\n  else printer.m_string = convert2string();\nendfunction : do_print\n\n\nfunction string gpio_uvc_sequence_item::convert2string();\n  string s;\n  s = super.convert2string();\n  $sformat(s, \"gpio_pin = 'd%5d, 'h%4h\", gpio_pin, gpio_pin);\n  if (delay_enable == GPIO_UVC_ITEM_DELAY_ON) begin\n    s = {s, $sformatf(\", delay_enable: %5d, delay_duration_ps: %5d\", delay_enable, delay_duration_ps)};\n  end\n  return s;\nendfunction : convert2string\n\n`endif // GPIO_UVC_SEQUENCE_ITEM_SV\n</code></pre>"},{"location":"uvm/templates/scoreboard/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_sequence_item</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>UVM Sequences</li> <li>Sequences</li> <li>UVM Sequence Items</li> <li>Transaction Methods</li> </ul> <p>Source Code</p> <ul> <li>[Source code <code>uvm_sequence_item.svh</code>](https://github.com/edaplayground/eda-playground/blob/master/docs/_static/uvm-1.2/src/seq/uvm_sequence_item.sv`</li> </ul>"},{"location":"uvm/templates/sequence-item/","title":"UVM Sequence Item","text":""},{"location":"uvm/templates/sequence-item/#summary","title":"Summary","text":"<p>The UVM Sequence Item is the base class for user-defined transactions that leverage the stimulus generation and control capabilities of the sequence-sequencer mechanism.</p>"},{"location":"uvm/templates/sequence-item/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once.</li> <li>Create user-defined transaction classes by extending the class <code>uvm_sequence_item</code>.</li> <li>Do not use field macros. (This comes at a heavy cost in terms of performance)</li> <li>Use the <code>rand</code> qualifier in front of any class member variables that might need to be randomized, now or in the future.</li> <li>After any member variables, define a constructor that includes a single string name argument with a default value of the empty string, a call to <code>super.new</code>, and is otherwise empty.</li> <li>After the constructor, always override the <code>convert2string</code>, <code>do_copy</code>, <code>do_compare</code>, <code>do_print</code>, and <code>do_record</code> methods.</li> <li>Always instantiate transaction objects using the factory. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/sequence-item/#code-example","title":"Code Example","text":"sequence_item.sv<pre><code>`ifndef GPIO_UVC_SEQUENCE_ITEM_SV\n`define GPIO_UVC_SEQUENCE_ITEM_SV\n\nclass gpio_uvc_sequence_item extends uvm_sequence_item;\n\n  `uvm_object_utils(gpio_uvc_sequence_item)\n\n  rand gpio_uvc_data_t       gpio_pin;\n  rand gpio_uvc_item_type_e  trans_type;\n  rand gpio_uvc_item_delay_e delay_enable;\n  rand int unsigned          delay_duration_ps;\n\n  extern function new(string name = \"\");\n\n  extern function void do_copy(uvm_object rhs);\n  extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);\n  extern function void do_print(uvm_printer printer);\n  extern function string convert2string();\n\n  // IMPORTANT -timescale=1ps/100fs to avoid Verdi errors\n  constraint delay_c {\n    soft delay_duration_ps inside {[1_000 : 10_000]};  // 1ns - 10ns\n  }\n\nendclass : gpio_uvc_sequence_item\n\n\nfunction gpio_uvc_sequence_item::new(string name = \"\");\n  super.new(name);\nendfunction : new\n\n\nfunction void gpio_uvc_sequence_item::do_copy(uvm_object rhs);\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  super.do_copy(rhs);\n  gpio_pin = rhs_.gpio_pin;\n  trans_type = rhs_.trans_type;\n  delay_enable = rhs_.delay_enable;\n  delay_duration_ps = rhs_.delay_duration_ps;\nendfunction : do_copy\n\n\nfunction bit gpio_uvc_sequence_item::do_compare(uvm_object rhs, uvm_comparer comparer);\n  bit result;\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  result = super.do_compare(rhs, comparer);\n  result &amp;= (gpio_pin == rhs_.gpio_pin);\n  return result;\nendfunction : do_compare\n\n\nfunction void gpio_uvc_sequence_item::do_print(uvm_printer printer);\n  if (printer.knobs.sprint == 0) `uvm_info(get_type_name(), convert2string(), UVM_MEDIUM)\n  else printer.m_string = convert2string();\nendfunction : do_print\n\n\nfunction string gpio_uvc_sequence_item::convert2string();\n  string s;\n  s = super.convert2string();\n  $sformat(s, \"gpio_pin = 'd%5d, 'h%4h\", gpio_pin, gpio_pin);\n  if (delay_enable == GPIO_UVC_ITEM_DELAY_ON) begin\n    s = {s, $sformatf(\", delay_enable: %5d, delay_duration_ps: %5d\", delay_enable, delay_duration_ps)};\n  end\n  return s;\nendfunction : convert2string\n\n`endif // GPIO_UVC_SEQUENCE_ITEM_SV\n</code></pre>"},{"location":"uvm/templates/sequence-item/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_sequence_item</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>UVM Sequences</li> <li>Sequences</li> <li>UVM Sequence Items</li> <li>Transaction Methods</li> </ul> <p>Source Code</p> <ul> <li>Source code <code>uvm_sequence_item.svh</code></li> </ul>"},{"location":"uvm/templates/sequence/","title":"UVM Sequence","text":""},{"location":"uvm/templates/sequence/#summary","title":"Summary","text":"<p>The UVM Sequence is </p>"},{"location":"uvm/templates/sequence/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/sequence/#code-example","title":"Code Example","text":"sequence_item.sv<pre><code>`ifndef GPIO_UVC_SEQUENCE_ITEM_SV\n`define GPIO_UVC_SEQUENCE_ITEM_SV\n\nclass gpio_uvc_sequence_item extends uvm_sequence_item;\n\n  `uvm_object_utils(gpio_uvc_sequence_item)\n\n  rand gpio_uvc_data_t       gpio_pin;\n  rand gpio_uvc_item_type_e  trans_type;\n  rand gpio_uvc_item_delay_e delay_enable;\n  rand int unsigned          delay_duration_ps;\n\n  extern function new(string name = \"\");\n\n  extern function void do_copy(uvm_object rhs);\n  extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);\n  extern function void do_print(uvm_printer printer);\n  extern function string convert2string();\n\n  // IMPORTANT -timescale=1ps/100fs to avoid Verdi errors\n  constraint delay_c {\n    soft delay_duration_ps inside {[1_000 : 10_000]};  // 1ns - 10ns\n  }\n\nendclass : gpio_uvc_sequence_item\n\n\nfunction gpio_uvc_sequence_item::new(string name = \"\");\n  super.new(name);\nendfunction : new\n\n\nfunction void gpio_uvc_sequence_item::do_copy(uvm_object rhs);\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  super.do_copy(rhs);\n  gpio_pin = rhs_.gpio_pin;\n  trans_type = rhs_.trans_type;\n  delay_enable = rhs_.delay_enable;\n  delay_duration_ps = rhs_.delay_duration_ps;\nendfunction : do_copy\n\n\nfunction bit gpio_uvc_sequence_item::do_compare(uvm_object rhs, uvm_comparer comparer);\n  bit result;\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  result = super.do_compare(rhs, comparer);\n  result &amp;= (gpio_pin == rhs_.gpio_pin);\n  return result;\nendfunction : do_compare\n\n\nfunction void gpio_uvc_sequence_item::do_print(uvm_printer printer);\n  if (printer.knobs.sprint == 0) `uvm_info(get_type_name(), convert2string(), UVM_MEDIUM)\n  else printer.m_string = convert2string();\nendfunction : do_print\n\n\nfunction string gpio_uvc_sequence_item::convert2string();\n  string s;\n  s = super.convert2string();\n  $sformat(s, \"gpio_pin = 'd%5d, 'h%4h\", gpio_pin, gpio_pin);\n  if (delay_enable == GPIO_UVC_ITEM_DELAY_ON) begin\n    s = {s, $sformatf(\", delay_enable: %5d, delay_duration_ps: %5d\", delay_enable, delay_duration_ps)};\n  end\n  return s;\nendfunction : convert2string\n\n`endif // GPIO_UVC_SEQUENCE_ITEM_SV\n</code></pre>"},{"location":"uvm/templates/sequence/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_sequence_item</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>UVM Sequences</li> <li>Sequences</li> <li>UVM Sequence Items</li> <li>Transaction Methods</li> </ul> <p>Source Code</p> <ul> <li>[Source code <code>uvm_sequence_item.svh</code>](https://github.com/edaplayground/eda-playground/blob/master/docs/_static/uvm-1.2/src/seq/uvm_sequence_item.sv`</li> </ul>"},{"location":"uvm/templates/sequencer/","title":"UVM Sequencer","text":""},{"location":"uvm/templates/sequencer/#summary","title":"Summary","text":"<p>The UVM Sequencer is</p>"},{"location":"uvm/templates/sequencer/#coding-guidelines","title":"Coding Guidelines","text":"<p>Coding Guidelines</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/sequencer/#code-example","title":"Code Example","text":"example_uvc_sequence_item.sv<pre><code>`ifndef GPIO_UVC_SEQUENCER_SV\n`define GPIO_UVC_SEQUENCER_SV\n\n//typedef uvm_sequencer #(gpio_uvc_sequence_item) gpio_uvc_sequencer;\n\nclass gpio_uvc_sequencer extends uvm_sequencer #(gpio_uvc_sequence_item);\n\n  `uvm_component_utils(gpio_uvc_sequencer)\n\n  gpio_uvc_config m_config;\n\n  extern function new(string name, uvm_component parent);\n\n  extern function void build_phase(uvm_phase phase);\n\nendclass : gpio_uvc_sequencer\n\n\nfunction gpio_uvc_sequencer::new(string name, uvm_component parent);\n  super.new(name, parent);\nendfunction : new\n\n\nfunction void gpio_uvc_sequencer::build_phase(uvm_phase phase);\n  if (!uvm_config_db#(gpio_uvc_config)::get(get_parent(), \"\", \"config\", m_config)) begin\n    `uvm_fatal(get_name(), \"Could not retrieve gpio_uvc_config from config db\")\n  end\nendfunction : build_phase\n\n`endif // GPIO_UVC_SEQUENCER_SV\n</code></pre>"},{"location":"uvm/templates/sequencer/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_sequencer</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>UVM Sequences</li> <li>Sequences</li> <li>UVM Sequence Items</li> <li>Transaction Methods</li> </ul> <p>Source Code</p> <ul> <li>Source code <code>uvm_sequencer.svh</code></li> </ul>"},{"location":"uvm/templates/test/","title":"UVM Test","text":""},{"location":"uvm/templates/test/#summary","title":"Summary","text":"<p>The **UVM Test ** is </p>"},{"location":"uvm/templates/test/#coding-guidelines","title":"Coding Guidelines","text":"<p>Tip</p> <ul> <li>Use conditional compilation guards to avoid compiling the same include file more than once. <pre><code>var_name = transaction_type::type_id::create(\"var_name\");\n</code></pre></li> </ul>"},{"location":"uvm/templates/test/#code-example","title":"Code Example","text":"sequence_item.sv<pre><code>`ifndef GPIO_UVC_SEQUENCE_ITEM_SV\n`define GPIO_UVC_SEQUENCE_ITEM_SV\n\nclass gpio_uvc_sequence_item extends uvm_sequence_item;\n\n  `uvm_object_utils(gpio_uvc_sequence_item)\n\n  rand gpio_uvc_data_t       gpio_pin;\n  rand gpio_uvc_item_type_e  trans_type;\n  rand gpio_uvc_item_delay_e delay_enable;\n  rand int unsigned          delay_duration_ps;\n\n  extern function new(string name = \"\");\n\n  extern function void do_copy(uvm_object rhs);\n  extern function bit do_compare(uvm_object rhs, uvm_comparer comparer);\n  extern function void do_print(uvm_printer printer);\n  extern function string convert2string();\n\n  // IMPORTANT -timescale=1ps/100fs to avoid Verdi errors\n  constraint delay_c {\n    soft delay_duration_ps inside {[1_000 : 10_000]};  // 1ns - 10ns\n  }\n\nendclass : gpio_uvc_sequence_item\n\n\nfunction gpio_uvc_sequence_item::new(string name = \"\");\n  super.new(name);\nendfunction : new\n\n\nfunction void gpio_uvc_sequence_item::do_copy(uvm_object rhs);\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  super.do_copy(rhs);\n  gpio_pin = rhs_.gpio_pin;\n  trans_type = rhs_.trans_type;\n  delay_enable = rhs_.delay_enable;\n  delay_duration_ps = rhs_.delay_duration_ps;\nendfunction : do_copy\n\n\nfunction bit gpio_uvc_sequence_item::do_compare(uvm_object rhs, uvm_comparer comparer);\n  bit result;\n  gpio_uvc_sequence_item rhs_;\n  if (!$cast(rhs_, rhs)) `uvm_fatal(get_type_name(), \"Cast of rhs object failed\")\n  result = super.do_compare(rhs, comparer);\n  result &amp;= (gpio_pin == rhs_.gpio_pin);\n  return result;\nendfunction : do_compare\n\n\nfunction void gpio_uvc_sequence_item::do_print(uvm_printer printer);\n  if (printer.knobs.sprint == 0) `uvm_info(get_type_name(), convert2string(), UVM_MEDIUM)\n  else printer.m_string = convert2string();\nendfunction : do_print\n\n\nfunction string gpio_uvc_sequence_item::convert2string();\n  string s;\n  s = super.convert2string();\n  $sformat(s, \"gpio_pin = 'd%5d, 'h%4h\", gpio_pin, gpio_pin);\n  if (delay_enable == GPIO_UVC_ITEM_DELAY_ON) begin\n    s = {s, $sformatf(\", delay_enable: %5d, delay_duration_ps: %5d\", delay_enable, delay_duration_ps)};\n  end\n  return s;\nendfunction : convert2string\n\n`endif // GPIO_UVC_SEQUENCE_ITEM_SV\n</code></pre>"},{"location":"uvm/templates/test/#reference-material","title":"Reference Material","text":"<p>Accellera</p> <ul> <li>UVM 1.2 Class Reference <code>uvm_sequence_item</code></li> <li>UVM 1.2 Class Reference Index</li> </ul> <p>Verification Methodology Cookbooks</p> <ul> <li>UVM Cookbook pdf</li> <li>UVM Sequences</li> <li>Sequences</li> <li>UVM Sequence Items</li> <li>Transaction Methods</li> </ul> <p>Source Code</p> <ul> <li>[Source code <code>uvm_sequence_item.svh</code>](https://github.com/edaplayground/eda-playground/blob/master/docs/_static/uvm-1.2/src/seq/uvm_sequence_item.sv`</li> </ul>"}]}